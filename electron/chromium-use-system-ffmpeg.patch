--- a/media/base/decoder_buffer.h
+++ b/media/base/decoder_buffer.h
@@ -37,7 +37,7 @@
     : public base::RefCountedThreadSafe<DecoderBuffer> {
  public:
   enum {
-    kPaddingSize = 32,
+    kPaddingSize = 64,
 #if defined(ARCH_CPU_ARM_FAMILY)
     kAlignmentSize = 16
 #else
--- a/media/ffmpeg/ffmpeg_common.cc
+++ b/media/ffmpeg/ffmpeg_common.cc
@@ -30,10 +30,10 @@
 
 }  // namespace
 
-// Why FF_INPUT_BUFFER_PADDING_SIZE? FFmpeg assumes all input buffers are
+// Why AV_INPUT_BUFFER_PADDING_SIZE? FFmpeg assumes all input buffers are
 // padded. Check here to ensure FFmpeg only receives data padded to its
 // specifications.
-static_assert(DecoderBuffer::kPaddingSize >= FF_INPUT_BUFFER_PADDING_SIZE,
+static_assert(DecoderBuffer::kPaddingSize >= AV_INPUT_BUFFER_PADDING_SIZE,
               "DecoderBuffer padding size does not fit ffmpeg requirement");
 
 // Alignment requirement by FFmpeg for input and output buffers. This need to
@@ -429,11 +429,11 @@
   } else {
     codec_context->extradata_size = config.extra_data().size();
     codec_context->extradata = reinterpret_cast<uint8_t*>(
-        av_malloc(config.extra_data().size() + FF_INPUT_BUFFER_PADDING_SIZE));
+        av_malloc(config.extra_data().size() + AV_INPUT_BUFFER_PADDING_SIZE));
     memcpy(codec_context->extradata, &config.extra_data()[0],
            config.extra_data().size());
     memset(codec_context->extradata + config.extra_data().size(), '\0',
-           FF_INPUT_BUFFER_PADDING_SIZE);
+           AV_INPUT_BUFFER_PADDING_SIZE);
   }
 }
 
@@ -570,11 +570,11 @@
   } else {
     codec_context->extradata_size = config.extra_data().size();
     codec_context->extradata = reinterpret_cast<uint8_t*>(
-        av_malloc(config.extra_data().size() + FF_INPUT_BUFFER_PADDING_SIZE));
+        av_malloc(config.extra_data().size() + AV_INPUT_BUFFER_PADDING_SIZE));
     memcpy(codec_context->extradata, &config.extra_data()[0],
            config.extra_data().size());
     memset(codec_context->extradata + config.extra_data().size(), '\0',
-           FF_INPUT_BUFFER_PADDING_SIZE);
+           AV_INPUT_BUFFER_PADDING_SIZE);
   }
 }
 
--- a/media/ffmpeg/ffmpeg_common.h
+++ b/media/ffmpeg/ffmpeg_common.h
@@ -23,10 +23,12 @@
 
 // Include FFmpeg header files.
 extern "C" {
+#if !defined(USE_SYSTEM_FFMPEG)
 // Disable deprecated features which result in spammy compile warnings.  This
 // list of defines must mirror those in the 'defines' section of FFmpeg's
 // BUILD.gn file or the headers below will generate different structures!
 #define FF_API_CONVERGENCE_DURATION 0
+#endif  // !defined(USE_SYSTEM_FFMPEG)
 // Upstream libavcodec/utils.c still uses the deprecated
 // av_dup_packet(), causing deprecation warnings.
 // The normal fix for such things is to disable the feature as below,
@@ -40,7 +42,9 @@
 MSVC_PUSH_DISABLE_WARNING(4244);
 #include <libavcodec/avcodec.h>
 #include <libavformat/avformat.h>
+#if !defined(USE_SYSTEM_FFMPEG)
 #include <libavformat/internal.h>
+#endif  // !defined(USE_SYSTEM_FFMPEG)
 #include <libavformat/avio.h>
 #include <libavutil/avutil.h>
 #include <libavutil/imgutils.h>
--- a/media/filters/ffmpeg_audio_decoder.cc
+++ b/media/filters/ffmpeg_audio_decoder.cc
@@ -372,7 +372,7 @@
 int FFmpegAudioDecoder::GetAudioBuffer(struct AVCodecContext* s,
                                        AVFrame* frame,
                                        int flags) {
-  DCHECK(s->codec->capabilities & CODEC_CAP_DR1);
+  DCHECK(s->codec->capabilities & AV_CODEC_CAP_DR1);
   DCHECK_EQ(s->codec_type, AVMEDIA_TYPE_AUDIO);
 
   // Since this routine is called by FFmpeg when a buffer is required for audio
--- a/media/filters/ffmpeg_demuxer.cc
+++ b/media/filters/ffmpeg_demuxer.cc
@@ -1223,6 +1223,7 @@
   // If no estimate is found, the stream entry will be kInfiniteDuration.
   std::vector<base::TimeDelta> start_time_estimates(format_context->nb_streams,
                                                     kInfiniteDuration);
+#if !defined(USE_SYSTEM_FFMPEG)
   const AVFormatInternal* internal = format_context->internal;
   if (internal && internal->packet_buffer &&
       format_context->start_time != static_cast<int64_t>(AV_NOPTS_VALUE)) {
@@ -1246,6 +1247,7 @@
       packet_buffer = packet_buffer->next;
     }
   }
+#endif  // !defined(USE_SYSTEM_FFMPEG)
 
   std::unique_ptr<MediaTracks> media_tracks(new MediaTracks());
 
--- a/media/filters/ffmpeg_video_decoder.cc
+++ b/media/filters/ffmpeg_video_decoder.cc
@@ -423,12 +423,11 @@
   codec_context_->thread_type =
       FF_THREAD_SLICE | (low_delay ? 0 : FF_THREAD_FRAME);
   codec_context_->opaque = this;
-  codec_context_->flags |= CODEC_FLAG_EMU_EDGE;
   codec_context_->get_buffer2 = GetVideoBufferImpl;
   codec_context_->refcounted_frames = 1;
 
   if (decode_nalus_)
-    codec_context_->flags2 |= CODEC_FLAG2_CHUNKS;
+    codec_context_->flags2 |= AV_CODEC_FLAG2_CHUNKS;
 
   AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
   if (!codec || avcodec_open2(codec_context_.get(), codec, NULL) < 0) {
